# -*- coding: utf-8 -*-
"""wmatching.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CTfpOnf290iPFMaRRPCod2Vbrm4ZNWDr
"""

import networkx as nx
from networkx.algorithms import bipartite
import numpy as np
from scipy.sparse import csr_matrix
import time
from scipy.optimize import linprog

A = np.random.rand(200,200)
n, m = A.shape
#A

G = bipartite.from_biadjacency_matrix(-csr_matrix(A))

top = nx.bipartite.sets(G)[0]
pos = nx.bipartite_layout(G, top)
nx.draw(G, pos)
G_labels = nx.draw_networkx_labels(G, pos)
G_edge_labels = nx.draw_networkx_edge_labels(G, pos)

start = time.perf_counter()
#matching = nx.max_weight_matching(G, maxcardinality=False, weight='weight')
matching = bipartite.matching.minimum_weight_full_matching(G)
end = time.perf_counter()
print(end - start)
matching = [(k, v) for k, v in matching.items() if k < n]
matrix = bipartite.biadjacency_matrix(G, G.nodes, G.nodes)
print('{}'.format(sum([matrix[m[0],m[1]] for m in matching])))

#print('{} {}'.format(sum([matrix[m[0],m[1]] for m in matching]), [matrix[m[0],m[1]] for m in matching]))
#[(k, v) for k, v in matching.items() if k < n]
#print('{} {}'.format(sum([matrix[m[0],m[1]] for m in matching]), [matrix[m[0],m[1]] for m in matching]))

nx.draw(G, pos)
G_labels = nx.draw_networkx_labels(G, pos)
G_edge_labels = nx.draw_networkx_edge_labels(G, pos)
G_e = nx.draw_networkx_edges(G, pos, edgelist=matching, edge_color='r')

lpC = A.reshape(n*m)
lpA = np.zeros((n+m, n*m))
bounds = [(0, None) for v in range(n*m)]
for i in range(n):
  for j in range(m):
    lpA[i, i*m+j] = 1
    lpA[n+j, i*m+j] = 1
lpB = np.full(n+m, 1)
#lpA, lpB, lpC, n, m, A

#sum([A[0,4], A[1,2], A[2, 3], A[3, 0], A[4, 1]])

start = time.perf_counter()
#res = linprog(-lpC, A_ub=lpA, b_ub=lpB, options={"bland": True}, method='simplex', bounds=bounds)
res = linprog(-lpC, A_ub=lpA, b_ub=lpB, method='revised simplex', bounds=bounds)
end = time.perf_counter()
print(end - start)
print(res.fun, res.success)
#print('{} {} {}'.format(sum([x for x in res.x if x > 0]), sum([lpC[i] for i, x in enumerate(res.x) if x > 0]), [(i,lpC[i], int(i/m), i%m, A[int(i/m), i%m]) for i, x in enumerate(res.x) if x > 0]))
lpMatching = []
for i in range(n):
  for j in range(m):
    if res.x[i*m+j] > 0.9: lpMatching.append((i,j+n))
#set(lpMatching)

nx.draw(G, pos)
G_labels = nx.draw_networkx_labels(G, pos)
G_edge_labels = nx.draw_networkx_edge_labels(G, pos)
G_e = nx.draw_networkx_edges(G, pos, edgelist=lpMatching, edge_color='r')

start = time.perf_counter()
res = linprog(-lpC, A_ub=lpA, b_ub=lpB, method='interior-point', bounds=bounds)
end = time.perf_counter()
print(end - start)
print(res.fun)
lpMatching = []
for i in range(n):
  for j in range(m):
    if res.x[i*m+j] > 0.9: lpMatching.append((i,j+n))
#set(lpMatching)

nx.draw(G, pos)
G_labels = nx.draw_networkx_labels(G, pos)
G_edge_labels = nx.draw_networkx_edge_labels(G, pos)
G_e = nx.draw_networkx_edges(G, pos, edgelist=lpMatching, edge_color='r')

"""# Pure Linear Programming ..."""

c = [-1, 4]
A = [[-3, 1], [1, 2]]
b = [6, 4]
res = linprog(c, A_ub=A, b_ub=b, method='interior-point')
res.x, res.success

res = linprog(c, A_ub=A, b_ub=b, options={"disp": True}, method='interior-point')
res.x



"""# Test"""

print('hi')
x = 2

print(x)